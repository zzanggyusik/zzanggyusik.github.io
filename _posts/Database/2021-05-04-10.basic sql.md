### The Database Language SQL

SQL이란 Structured Query Language로, Query를 하기위해 설계된 언어입니다.



### Dialects of SQL

- SQL-86 / ANSI SQL - a standard adopted in 1986 : 미국 정부에서 표준화한 SQL
- SQL-92 / SQL2 - an updated standard adopted in 1992
- SQL-99 / SQL3 - an updated standard adopted in 1999

*objects ,triggers ,recursion

SQL3로 오면서 위 세 개의 기능들이 추가되었는데, 문제는 SQL3가 표준화 되기 전에 이미 각각의 DB서버에서 자기들 방식으로 구현을 해버려서 사용법이 다 다르다는 문제점이 생기게 되었습니다.

- SQL : 2003

*XML-related features, sequence and auto-generated-value column

- SQL : 2006

*XML-related features



교재에서는 SQL2의 기능들 위주로 설명합니다.

### Example Database Schema

![image](https://user-images.githubusercontent.com/76269316/116992716-6e35c900-ad11-11eb-9f3c-c2cd9868dcc2.png)

위 E/R 다이어그램을 schema로 나타내면 다음과 같습니다.

**Movie(<u>title</u>, <u>year</u>, length, genre, studioName, producerCNo)**

**MovieStar(<u>name</u>, address, gender, birthDate)**

**StarsIn(movieTitle, movieYear, starName)**

**Studio(<u>name</u>, address, presCNo)**

**MovieExec(<u>certNo</u>, name, address, netWorth)**



**Movie** table을 보면 Movie(<u>title</u>, <u>year</u>, length, genre, studioName, producerCNo)인데, 이 중 Studio와의 다대일 관계를 구현하기 위해 foreign key (https://cutewelshcorgi.github.io/9.from-er-models-to-relations/#example-1)로 studio의 key인 name을 가져왔고*(name이 Movie의 name인지 studio의 name인지 명확하게 해주기 위해 studioName으로 이름 설정)*

마찬가지로, Execs와의 다대일 관계를 구현하기 위해 foreign key로 producerCNo를 가져왔습니다.



MySQL에는 

[MySQL]: https://www.mysql.com/products/workbench/

라는 E/R 다이어그램을 쉽게 그려주는 툴이 있는데, 이를 이용해서 그린 그림이 아래 그림입니다.

![image](https://user-images.githubusercontent.com/76269316/117014217-8dd9eb00-ad2b-11eb-8e19-800bcf704be3.png)

StarsIn 테이블(StarsIn relationship set을 변환한 테이블)을 보면 다대다 관계를 특이하게 설정한 걸 볼 수 있는데, 

먼저 Movie와 StarsIn을 다대일 관계로 설정합니다. 그러면 movieTitle, movieYear가 foreign key로 들어오게되고,

그런 다음 MovieStar와 StarsIn을 다대일 관계로 설정합니다. 그러면 마찬가지로 starName이 foreign key로 들어오게 되는데, 두 개의 다대일 관계(Movie - StarsIn, MovieStar - StarsIn)를 합쳐서 다대다 관계로 해석합니다.

다대일 관계는 그냥 관계를 설정하면 foreign key가 들어와서 관계가 설정됩니다.



MySQL을 사용하면 스키마랑 E/R 다이어그램을 연결해서 설계를 쉽게 할 수 있습니다.



실제 SQL에서 Query를 이용해서 원하는 정보를 뽑아내는 걸 차근차근 해보겠습니다.

먼저 query가 주어지면 우리가 뽑아내고 싶은 질의에 관련된 정보가 저장된 테이블이 몇 개인지 확인합니다. (두 개 이상이면 join을 사용해야하므로)

이번 포스트에서는 한 개인 경우만 다루도록 하겠습니다.



**1990년에 디즈니 스튜디오에서 제작된 모든 영화를 찾아라** 를 SQL Query로 주면 다음과 같습니다.

```sql
SELECT *
FROM Movie
WHERE studioName = 'Disney' AND year = 1990;
```

이전까지 저희가 다뤘던 relational expression을 사용해서 표현하면 다음과 같습니다.

**π title, year, length, inColor, studioName, producerCNo (σ studioName = 'Disney' ^ year = 1990(Movie))**

**σ studioName = 'Disney' ^ year = 1990 (Movie)**



**1990년에 디즈니 스튜디오에서 제작된 모든 영화의 title과 length를 찾아라** 는 다음과 같습니다.

```sql
SELECT title, length
FROM Movie
WHERE studioName = 'Disney' AND year = 1990;
```

**π title, length(σ studioName = 'Disney' ^ year = 1990(Movie))**



살짝 규칙이 보이시나요? SQL에서 SELEC는 π, FROM은 테이블, WHERE는 σ을 나타냅니다.

```sql
SQL:							Relational Algebra:
SELECT L				←		π L (σ c (R))
FROM R					→
WHERE C
```

위 두 식은 필요충분조건(iff - if and only if) 관계입니다.  굳이 SQL로 저렇게 풀어서 쓰는 방식으로 만든 이유는 컴퓨터공학과를 전공하지 않더라도 (Relational Algebra를 모르더라도) 데이터베이스를 사용할 수 있도록 문장 형식으로 형식으로 만든 것입니다.



### Projection in SQL

결과 테이블의 column 값을 바꿀 수도 있습니다.

```sql
SELECT title AS name, length AS duration
FROM Movie
WHERE studioName = 'Disney' AND year = 1990;
------------------------------------------------------------------------
/* AS 키워드를 주지 않아도 됩니다. */
SELECT title name, length duration
FROM Movie
WHERE studioName = 'Disney' AND year = 1990;
```



분 단위의 length를 시 단위로 표현하고 싶어서 60.0으로 나눴는데, 이런 expression을 column 이름으로 사용하거나 Auto generation 해주는 DB 서버들도 있지만 그거보다는 이렇게 AS해서 column 이름을 지정해주는게 좋습니다.

그 뒤 'hrs.' AS inHours의 경우에는 studioName이 Disney이고 year가 1990인 모든 tuple에 대해서 hrs.라는 상수 String을 붙입니다.

```sql
SELECT title AS name, length / 60.0 AS lengthInHours, 'hrs.' AS inHours
FROM Movie
WHERE studioName = 'Disney' AND year = 1990;
```



실행 결과는 다음과 같습니다. hrs.라는 상수 String의 값이 column으로 추가된 것과 length가 1.98333···이라는 floating numer가 된 것을 볼 수 있습니다.

|     name     | lengthInHours  | inHours |
| :----------: | :------------: | :-----: |
| Pretty Woman | 1.983333333··· |  hrs.   |



##### Case Expression(SQL2)

C language의 if문처럼 조건문을 넣을 수도 있습니다.

아래 SQL문을 보면 length가 3600 이상인 경우 3600으로 나누고, 3600 미만인 60 이상인 경우는 60으로 나누게 됩니다.

```sql
SELECT title AS name,
	   case when length >= 3600 then length / 3600.0
	   		when length >= 	 60 then length / 60.0
	   end AS length
FROM Movie;
```



SQL Case문은 다음과 같은 두가지 syntax로 사용할 수 있습니다.

- Generic Form Syntax

```sql
CASE WHEN <condition> THEN <result>
	 WHEN <condition> THEN <result>
	 [···]
	 [ELSE <result>]
END
```



* Simple Form Syntax

```sql
CASE <common operator>
	 WHEN <expression> THEN <result>
	 WHEN <expression> THEN <result>
	 [···]
	 [ELSE <result>]
END
```

Generic Form의 경우 condition에는 expression(조건식)이 들어가게되고, Simple Form의 경우 common operator에 값이 들어가게 됩니다.

C language의 if문(Generic Form), switch문(SImple Form) 정도로 볼 수 있겠네요.



### SQL is Case Insensitive

SQL은 attributes, relations, alias, keywords의 대소문자를 구별하지 않습니다.

```sql
SELECT title AS name, length AS duration
FROM Movie
WHERE studioName = 'Disney' AND year = 1990;
```

여기서 SELECT, FROM, WHERE 같은 keywords나 title, length 같은 attributes, 심지어 name, duration 같은 alias들을 모두 대소문자 구분하지 않는다는 뜻입니다.

즉 FROM = from =FrOm은 모두 SQL에서 알아서 FROM으로 변경하여 처리한다는 의미입니다. 



하지만 Constant String(상수 String)의 경우에는 **<u>데이터이기 때문에</u>** 대소문자를 구분합니다.

'DISNEY' ≠ 'disney' ≠ 'Disney' 는 모두 다른 String입니다. 



### Selection in SQL

|     Comparison Operators      |             =, <>(같지 않음 기호), <, >, <=, >=              |
| :---------------------------: | :----------------------------------------------------------: |
|       Logical Operators       |                         AND, OR, NOT                         |
|     Arithmetic Operators      |                          +, -, *, /                          |
| String Concatenation Operator |                   \|\| (String 2개를 합침)                   |
|    Pattern Match Operator     |                             LIKE                             |
|  Values (계산에 사용되는 값)  | constants(상수 - 숫자, String) or attributes of the relations mentioned after FROM (From에 있는 relational attributes) |
