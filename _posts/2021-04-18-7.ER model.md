이번 포스팅에서는 Entity Relationship Model (E/R Model)에 대해서 다룹니다.

그 전에 데이터베이스를 설계하는 과정을 보면



### Process of Designing a Database

+Domain 영역 : 데이터베이스화하고자 하는 real world를 말합니다.

H 대학교 수강신청 데이터베이스를 만든다고 하면, 

학생 정보, 교과목 정보가, 교수 정보 등등이 필요합니다. → 1

어떤 학생이 어떤 과목을 수강신청하려면 학생과 과목 사이의 관계가 필요합니다. → 2

또한 담당교수와 교과목 정보 사이에도 관계가 필요합니다.

이때 각각의 정보와 관계는 꼭 필요한 것들만 저장합니다. 학교 근처 식당 정보는 수강 신청 데이터베이스에는 필요 없는 정보겠지요?

1. Domain 영역에서(real world에서) 어떤 정보를 데이터베이스에 저장할 것인지 분석합니다.
2. components 사이의 relationship을 분석합니다.
3. database schema를 기술합니다.
4. DBMS가 schema를 받아서 테이블을 생성합니다.



디자인을 도와주기 위한 대표적인 도구들이 몇가지 있는데 저희는 그 중 E/R 모델에 대해 알아보도록 하겠습니다.

### High-Level Design Models

- E/R (Entity-Relationship) model

밑에 두 개는 객체 지향 프로그램 언어에서 표준화된 언어이기 때문에 넘어가도록 하겠습니다.

- UML(Unified Modeling Language) model 
- ODL(Object Definition Language) model



### Database Modeling and Implementation Process

**Ideas(real world) → E/R → Relational Schema → Relational DBMS**

​                                 **→ UML(ODL) → Object-Oriented DBMS**

UML이나 ODL도 relational schema로 변환하는게 가능하긴 하지만 E/R 모델을 주로 사용합니다.

첫 번째 포스팅에서 얘기했던 것처럼 Relational DBMS가 현재 DBMS 시장을 거의 차지하고 있고, E/R Model로 설계한 다음 Relational Model로 conversion하는 이유는 **E/R Model이 더 high level(사용자 쪽에 가까운 언어)이기 때문에 초기 단계에 설계하기가 쉽고, 또한 Relational Model로 conversion하는게 어렵지 않기 때문에 사용합니다.**



### E/R Model

- Entity Sets : ![image](https://user-images.githubusercontent.com/76269316/115132300-f93c7100-a039-11eb-90e7-d9a0f004f98a.png)

real world에는 개별적인 entity들이 존재한다고 보는데 그 중 같은 type의 entity들을 모은 것이 **Entity Set**

예를 들어 H대학교 학생들이 있다고 할 때, 이들은 개별적으로는 다 다른 학생이지만, H대학교 학생이라는 점에서 Entity Set으로  묶을 수 있음.



- Attributes : ![image](https://user-images.githubusercontent.com/76269316/115132366-7b2c9a00-a03a-11eb-9483-e0972b3e1046.png)

Entity나 Relationship의 속성을 기술하기 위해 **Attributes**를 붙입니다.

Attributes는 String, float, Integer 같은  **primitive type**만을 사용합니다. (Array, LinkedList, ··· X)



- Relationship Sets : ![image](https://user-images.githubusercontent.com/76269316/115132400-c5158000-a03a-11eb-9f99-b8659ce2ab86.png)

 각각의 같은 type의 Entity와 Entity(Entity Set말고 그냥 Entity 하나) 사이의 개별적인 relation이 있을 수 있는데 이런 같은 종류의 Entity 사이의 개별적인 relationship을 모아서 **Relationship Set**이라고 합니다.



예시를 가지고 설명하도록 하겠습니다.

비디오 가게에서 손님이 비디오를 빌리러 왔을 때 빠르게 찾아주기 위해서 데이터베이스화 하려고 한다고 가정해보죠.

영화 제목으로 찾으려는 사람도 있을테고, 영화에 출연한 스타의 이름으로 찾으려는 사람도 있을테고, 영화 스튜디오 이름으로 찾으려는 사람도 있을겁니다.

각각의 영화는 개별적으로 다른 Entity이지만, 같은 type(영화)입니다. 때문에 Entity Set으로 정의할 수 있는거죠. 스타나, 영화 스튜디오도 마찬가지입니다.

|   Entity    |     Entity Set     |
| :---------: | :----------------: |
| each movie  | the set of movies  |
|  each star  |  the set of stars  |
| each studio | the set of studios |



그럼 우선, Entity Set을 정했으니 이제 각각의 Entity Set이 어떤 attribute를 갖는지 알아보기 위해 우선 **set으로 생각하지말고** Entity 각각이 어떤 속성을 갖는지 한번 보겠습니다.



아래 그림은 저자가 설명을 돕기 위해 모델링한 것인데,

![image](https://user-images.githubusercontent.com/76269316/115132558-5b967100-a03c-11eb-9cd8-cc23760c2a96.png)

각각의 영화는 Title, Year, Length, Genre라는 attributes를 갖습니다. (실제로는 더 있을 수더 있는데 저자가 설명을 위해서 핵심적인 것 4개만 뽑은 겁니다.)

위처럼 개체를 표현하는 건 그래픽 에디터를 사용해야 하기 때문에 머리 속으로 생각하긴 쉬우나 그리기 어렵기 때문에, 그냥 텍스트 형태로 **(Star Wars, 1977, 124, sciFi)** 이렇게 작성해도 동일한 표현입니다.

![image](https://user-images.githubusercontent.com/76269316/115132595-913b5a00-a03c-11eb-8e96-b4b83ea59cbe.png)

스타의 경우 Name, Address라는 attributes를 갖습니다. (address는 영화를 찾는데는 별 도움이 되진 않는데, 하나만 넣기에는 밋밋해보여서 저자가 그냥 넣은 것 같습니다.)

마찬가지로 (Harrison Ford, 789 Palm Dr.Beverly Hills)도 동일한 표현입니다.



따라서 Movie와 Star의 Entity들은 저런 속성을 갖고 있는데 각각의 Entity Set에 속하는 Movie 3개, Star 3개를 다음과 같이 표현할 수 있습니다.

![image](https://user-images.githubusercontent.com/76269316/115132644-f8590e80-a03c-11eb-91d3-ea73e8dbbfe6.png)

앞에서 설명한 **이 ![image](https://user-images.githubusercontent.com/76269316/115132300-f93c7100-a039-11eb-90e7-d9a0f004f98a.png) 기호는 개별적인 Entity를 나타내는게 아니라 Entity들을 대표하는 Entity Set을 나타내는 거라는 걸 명심해야합니다.**



실제로 E/R 모델로 모델링하면 이렇게 됩니다.

![image](https://user-images.githubusercontent.com/76269316/115132769-04919b80-a03e-11eb-83c6-4cd427672628.png)



![image](https://user-images.githubusercontent.com/76269316/115132772-0e1b0380-a03e-11eb-9147-6099b681a4b4.png)

![image](https://user-images.githubusercontent.com/76269316/115132366-7b2c9a00-a03a-11eb-9483-e0972b3e1046.png) 기호 안에 있는 건 attribute를 얘기하고, ![image](https://user-images.githubusercontent.com/76269316/115132300-f93c7100-a039-11eb-90e7-d9a0f004f98a.png) 기호는 Entity Set을 의미합니다.

Attributes는 String, float, Integer 같은  **primitive type**만을 사용합니다. (Array, LinkedList, ··· X)



### Extended Entity-Relationship Model (EER)

EER에서는 attribute를 다음과 같이 확장할 수 있습니다.

- **simple versus composite** : primitive한 attribute의 composite type을 지원
- single-valued versus **multivalued**
- stored versus **derived** : 다른 것으로부터 유도되는

책에서는 깊게 다루지 않기 때문에 그냥 읽어보시기만 해도 될 것 같습니다.



### Simple / Composite Attribute

- E/R Model (Simple Attribute)

![image](https://user-images.githubusercontent.com/76269316/115132888-0e67ce80-a03f-11eb-82aa-e44a6d60165d.png)

- EER Model (Composite Attribute)

C Language로 봤을 때 Structure Type 정도로 볼 수 있습니다.

![image](https://user-images.githubusercontent.com/76269316/115132900-250e2580-a03f-11eb-95e5-09e781045cd3.png)

Composite 형태로 만드는 것도 틀렸다고 할 수는 없습니다. 경우에 따라 firstName이나 lastName을 처리해야하는 경우도 있을 수 있으니까요.



### Singled-valued / Multivalued Attribute

- E/R Model (Single-valued attribute)

name을 하나 밖에 저장 못함.

![image](https://user-images.githubusercontent.com/76269316/115132888-0e67ce80-a03f-11eb-82aa-e44a6d60165d.png)

- EER Model (Multivalued attribute)

C Language Array처럼 여러 개의 값을 저장할 수 있습니다.

![image](https://user-images.githubusercontent.com/76269316/115132932-6f8fa200-a03f-11eb-9362-6675807fd93d.png)



### Stored / Derived Attribute

- E/R Model (Stored Attribute)

EER의 Derived Attribute와 구분하기 위해 E/R은 Stored Attribute라고 부르는데 Star tuple이 저장될 때 name attribute가 실제로 저장되는 걸 의미합니다.

![image](https://user-images.githubusercontent.com/76269316/115132888-0e67ce80-a03f-11eb-82aa-e44a6d60165d.png)

- EER Model (Derived attribute)

Stars의 다른 attribute로부터 계산해서 뽑아낼 수 있다는 걸 의미합니다. birthDate라는 attribute로부터 오늘 날짜를 기준으로 나이를 계산할 수 있습니다.

이렇게 다른 속성으로부터 뽑아낼 수 있는 속성을 Derived attribute라고 합니다.

![dervied attribute](https://user-images.githubusercontent.com/76269316/115133224-7cad9080-a041-11eb-873e-abcbf92c7613.png)



