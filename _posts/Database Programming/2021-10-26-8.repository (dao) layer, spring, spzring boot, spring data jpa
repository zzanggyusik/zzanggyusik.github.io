---
title: "8.Repository (DAO) Layer, Spring, Spring Boot, Spring Data JPA"
toc: true
toc_label: "Repository (DAO) Layer, Spring, Spring Boot, Spring Data JPA"
toc_sticky: true

categories:
  - Database Programming
tags:
  - 데이터베이스 프로그래밍
last_modified_at: 2021-10-26

---

### Hiberbate Mapping xml vs annotation

**03-1-harnessing-hibernate-xml vs 03-2-harnessing-hibernate-ann**

![image](https://user-images.githubusercontent.com/76269316/138808141-20eccd64-a691-4f87-87f1-bb7acb4f39a7.png)

<br>

**03-1-harnessing-hibernate-xml**

mapping 정보를 xml로 준 프로젝트

![image](https://user-images.githubusercontent.com/76269316/138814119-2d868152-5ab3-4a1f-a046-119a6a06e897.png)

**Track.hbm.xml**

```xml
<?xml version="1.0"?>

<!DOCTYPE hibernate-mapping PUBLIC
"-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">  <!-- 헤더 파일, dtd(mapping tag를 정의해놓은 파일) -->

<hibernate-mapping>

  <class name="com.oreilly.hh.data.Track" table="TRACK">  <!-- table="TRACK" 생략시 Track이 테이블 이름이 됨 (SQL은 대소문자 구분x) -->

    <meta attribute="class-description">  <!-- meta 정보는 xml을 이용해서 소스 코드를 generation할 때 필요한데 지금은 그냥 comment 정도라고 생각 -->
      Represents a single playable track in the music database.
      @author Jim Elliott (with help from Hibernate)
    </meta>

    <id name="id" type="integer" column="TRACK_ID">  <!-- column 이름 변경 가능)
      <meta attribute="scope-set">protected</meta>
      <generator class="native"/>  <!-- 데이터베이스 서버가 가장 잘하는 방식으로 auto generation key 생성 -->
    </id>

    <property name="title" type="string" not-null="true"/>  <!-- property type은 java type, database type x 하이버네이트가 사용하는 type O → 자바로 오면 string class, 데이터베이스로 가면 variable character가 됨

    <property name="filePath" type="string" not-null="true"/>

    <property name="playTime" type="java.time.LocalTime">  <!-- 이렇게 자바 type을 직접 명시해도 됨 -->
      <meta attribute="field-description">Playing time</meta>
    </property>

    <property name="added" type="java.time.LocalDate">
      <meta attribute="field-description">When the track was created</meta>
    </property>

    <property name="volume" type="short" not-null="true">
      <meta attribute="field-description">How loud to play the track</meta>
    </property>
  </class>

  <query name="com.oreilly.hh.tracksNoLongerThan">
    <![CDATA[
    SELECT track
    FROM Track AS track
    WHERE track.playTime <= :length
    ]]>
  </query>

</hibernate-mapping>
```

xml로 mapping한 경우 hibernate.cfg.xml에 mapping 정보를 가르쳐줘야 함

![image](https://user-images.githubusercontent.com/76269316/138814159-253d7369-a901-4fcf-ab33-39b0e92701dc.png)

hibernate.cfg.xml

```xml
    <!-- List all the entities we're using -->
    <mapping resource="com/oreilly/hh/data/Track.hbm.xml"/>
```

<br>

+src/main/java 밑에 xml 파일을 넣고 싶은 경우

원래는 xml 파일은 resources 디렉토리에, java 파일은 java 디렉토리에 넣는데

![image](https://user-images.githubusercontent.com/76269316/138814202-b3e6b821-deb4-4bc9-ab76-14383379e022.png)

일반적으로 생각했을 때 mapping 정보니까 다음과 같이 mapping 정보(Track.hbm.xml)와 mapping 하려는 클래스 파일(여기서는 Track.java)이 같이 있는 게 보기 좋음

![image](https://user-images.githubusercontent.com/76269316/138814235-829506f0-c22c-4e56-a21d-9f58a4e3ecea.png)

이렇게 할 경우 build.gradle에서 source 디렉토리 밑에 resource 파일을 넣었다고 알려줘야 한다.

```groovy
sourceSets{
	main.resources.srcDir 'src/main/java'  //main의 resource가 ‘src/main/java’ 밑에도 있다.
	test.resources.srcDir 'src/test/java'  //test의 resource가 ‘src/test/java’ 밑에도 있다.
}
```

src/main/java 디렉토리에서는 자바 파일 외에는 무시하기 때문에 이 코드를 생략하면 컴파일 후에 Track.hbm.xml 파일이 안 보임

xml 방식은 에디터에서도 xml을 지원해야 하고 xml 코드도 따로 관리해야 하니까 annotation 방식을 많이 씀

하지만 xml 방식은 mapping을 위한 부가정보가 분리돼 있기 때문에 순수한 자바 코드임 (POJO)

<br>

**03-2-harnessing-hibernate-ann**

mapping 정보를 annotation으로 준 프로젝트

<br>

![image](https://user-images.githubusercontent.com/76269316/138814276-d48aaacc-402e-44e1-b33e-315ce158a4fc.png)

**Track.java**

```java
package com.oreilly.hh.data;

import java.time.LocalDate;
import java.time.LocalTime;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.NamedQuery;
import javax.persistence.Table;

@NamedQuery(name = "com.oreilly.hh.tracksNoLongerThan",
            query = "SELECT track FROM Track AS track WHERE track.playTime <= :length")

@Entity  //Entity annotation을 붙이면 hibernate가 table로 인식

@lombok.Data  //java에서 entity class로 사용하려면 필드를 private로 선언하고 getter, setter를 만들어줘야 하는데 컴파일 직전에 lombok이 생성해줌
@lombok.EqualsAndHashCode(of="id")  
public class Track  implements java.io.Serializable {

    @Id  //primary key
    @Column(name = "TRACK_ID")  //데이터베이스에서는 primary key 이름으로 테이블이름_id를 사용하는게 관행, column 이름을 변경 
    @GeneratedValue(strategy = GenerationType.AUTO)  //auto generation key (각 DB 서버마다 잘하는 방식 identity나 sequence 사용)
    private Integer id;
    private String title;
    private String filePath;
    private LocalTime playTime = LocalTime.of(0, 0, 0);
    private LocalDate added = LocalDate.now();
    private short volume = 0;

    public Track() {
    }

    public Track(String title, String filePath, LocalTime playTime) {
        this.title = title;
        this.filePath = filePath;
        this.playTime = playTime;
    }

    public Track(String title, String filePath, LocalTime playTime, short volume) {
        this.title = title;
        this.filePath = filePath;
        this.playTime = playTime;
        this.volume = volume;
    }
}
```

데이터베이스에 저장할 때 지켜야 하는 것들

<span style="color:red">1. Default 생성자 만들기 (argument가 없는 생성자)</span>

<span style="color:red">2. property는 private로 선언하고 getter와 setter로만 접근</span>

<span style="color:red">3. 데이터베이스에서 entity에서 해당하는 tuple을 읽어왔을 때 기존에 메모리에 있던 것과 같은지 entity level에서 비교해야함</span>

lombok.Data의 default는 모든 필드를 다 비교 (@lombok.EqualsAndHashCode(of="id") hibernate는 id만 같으면 됨)

- eqauls: 두 객체의 내용이 같은지, 동등성 비교 연산자
- hashCode: 두 객체가 같은 객체인지, 동일성 비교 연산자

<br>

annotation으로 mapping한 경우에도hibernate.cfg.xml에 mapping 정보를 갖고 있는 클래스를 가르쳐줘야 함

![image](https://user-images.githubusercontent.com/76269316/138814357-669c22e2-f7b4-4dcc-90f4-d9094580e088.png)

**hibernate.cfg.xml**

```xml
    <!-- List all the entities we're using -->
    <mapping class="com.oreilly.hh.data.Track"/>
```

<br><br>

### Hibernate vs JPA

**03-3-harnessing-jpa vs 03-2-harnessing-hibernate-ann**

![image](https://user-images.githubusercontent.com/76269316/138811501-1b2ab716-5f4f-44cb-a76d-69e783f621fd.png)

jpa는 나중에 추가됐기 때문에 annotation 방식이 먼저 표준화되고, xml이 나중에 추가됨 (수업에서는 jpa mapping 정보를 xml로 주는 걸 다루지 않음)

**03-3-harnessing-jpa**

jpa는 api spec만 주어진거고 hibernate로 구현

jpa를 사용하는 경우 hibernate jpa api를 이용한다고 함

![image](https://user-images.githubusercontent.com/76269316/138814415-1eed5e4e-f57a-4fb4-99e6-b7af6f9da4c8.png)

**03-2-harnessing-hibernate-ann**

![image](https://user-images.githubusercontent.com/76269316/138814495-e6d95d5b-c335-4b45-abc4-3417da5d2565.png)

hibernate를 사용하는 경우 hibernate native api를 이용한다고 함

**Track.java**

![image](https://user-images.githubusercontent.com/76269316/138810579-9b660758-fb2f-4590-b867-bd8a4ac4f261.png)

jpa도 hibernate로 구현했기 때문에 annotation의 경우 두 프로젝트가 동일

<br>

**차이점**

1. hibernate의 경우 singleton pattern 구현을 위해 session factory 생성 클래스 파일을 따로 만듦

![image](https://user-images.githubusercontent.com/76269316/138814553-1717d5e0-be30-44ef-80e5-73b6f0532482.png)

**HibernateUtil5**

```java
package com.oreilly.hh;

import org.hibernate.SessionFactory;
import org.hibernate.boot.Metadata;
import org.hibernate.boot.MetadataSources;
import org.hibernate.boot.registry.StandardServiceRegistry;
import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
import org.hibernate.cfg.Configuration;

public class HibernateUtil5 {
    private static final SessionFactory sessionFactory = buildSessionFactory();  //static: 이 클래스 내에서만 사용 가능한 global variable (class 생성시 만들어짐)

    private static SessionFactory buildSessionFactory() {
        // A SessionFactory is set up once for an application!
        var registry = new StandardServiceRegistryBuilder()
            .configure()  //configures settings from hibernate.cfg.xml 파일을 읽어들임
            .build();
        try {
            return new MetadataSources(registry)
                .buildMetadata()
                .buildSessionFactory();
        } catch (Exception e) {
            // The registry would be destroyed by the SessionFactory,
            // but we had trouble building the SessionFactory
            // so destroy it manually.
            StandardServiceRegistryBuilder.destroy(registry);

            // Make sure you log the exception, as it might be swallowed
            System.err.println("Initial SessionFactory creation failed." + e);
            throw new ExceptionInInitializerError(e);
        }
    }

    public static SessionFactory getSessionFactory() {
        return sessionFactory;
    }

    public static void close() {
        sessionFactory.close();
    }
}
```

session factory object를 하나 만들고, session factory object를 통해 필요할 때마다 session object를 만들어서 transaction도 관리하고 save나 persistence 메소드를 통해 저장

session factory는 자바 프로그램이 끝날 때까지 object가 단 한 개만 존재해야 하는데, 자바는 그런 기능을 지원하지 않기 때문에 이런 식으로 클래스 파일을 하나 따로 만들어서 구현함

<br>

jpa의 경우 따로 클래스를 생성하지 않고 직접 entity manager를 만들어서 사용 (Hibernate5.java 파일이 없음)

```java
        var emf = Persistence.createEntityManagerFactory("default");
        var em  = emf.createEntityManager();
```

<br>

![image](https://user-images.githubusercontent.com/76269316/138814590-20f292c0-02b1-409c-a9cc-dc6fc579e5f7.png)

**CreateTest.java**

```java
package com.oreilly.hh;

import java.time.LocalTime;

import javax.persistence.Persistence;

import com.oreilly.hh.data.Track;

public class CreateTest {

    public static void main(String args[]) {

        var emf = Persistence.createEntityManagerFactory("default");  //persistence unit 이름을 default로 줌 (한 번만 생성하고 리턴된 걸 재사용해야 함)
        var em  = emf.createEntityManager();
        var tx  = em.getTransaction();  //transaction object를 가져온 다음에 시작 → 이 방식은 hibernate try, catch 방식과 동일

        try {
            tx.begin();

            var track = new Track("Russian Trance",
                                  "vol2/album610/track02.mp3",
                                  LocalTime.of(00,03,30));
            em.persist(track);

            track = new Track("Video Killed the Radio Star",
                              "vol2/album611/track12.mp3",
                              LocalTime.of(00,03,49));
            em.persist(track);

            track = new Track("Gravity's Angel",
                              "vol2/album175/track03.mp3",
                              LocalTime.of(00,06,06));
            em.persist(track);

            tx.commit();
        } catch (RuntimeException e) {
            tx.rollback();
            throw e;
        } finally {
            em.close();
        }

        emf.close();
    }
}
```

<br>

2. schema generation

hibernate의 경우 mapping 정보로부터 schema generation 하는게 잘 고려돼 있었음

jpa는 schema generation이 부족해 schema generation을 간략하게 하기 위해 따로 utility program을 만듦(GenerateSchema.java)

![image](https://user-images.githubusercontent.com/76269316/138814686-4d4e0f7a-2a40-41ac-af99-eb18b534f095.png)

**GenerateSchema.java**

schema generation script를 확인할 때 사용

```java
package com.oreilly.hh;

import javax.persistence.Persistence;

public class GenerateSchema {
    public static void main(String args[]) {
        var emf = Persistence.createEntityManagerFactory("genSchema");
        emf.close();
    }
}
```

hibernate session factory object를 만들면 schema generation 할 수 있는데, 비슷한 방식으로 만듦

<br>

cf) hibernate schema generation

mapping 정보를 hibernate에 가르쳐주면 이 정보로부터 데이터베이스 스키마를 생성할 수 있는데 그걸 화면에 출력시키기 위한 task

이걸 보면 hibernate가 mapping을 제대로 했는지 확인할 수 있음

![image](https://user-images.githubusercontent.com/76269316/138814735-937bb363-3cd7-445a-9859-889aebda6a74.png)

**build.gradle**

```groovy
  task schema(dependsOn: classes, type: JavaExec) {
    group = 'Application'
    description = 'Generates the database schema from entities'

    mainClass = 'org.hibernate.tool.hbm2ddl.SchemaExport'
    args '--config=hibernate.cfg.xml', '--text', '--format', '--delimiter=;'
    //args '--create'
    classpath = sourceSets.main.runtimeClasspath
  }
```

--config: hibernate configure파일 위치 

--text: 화면에 text로 출력

--format: format을 xml로

--delimiter: delimeter를 ;로 설정

--create: 실제 데이터베이스에도 생성

classpath: dependency에 기술된 runtimeClasspath를 가져옴

<br>

3.  persistence.xml vs hibernate.cfg.xml

|                     03-3-harnessing-jpa                      |                03-2-harnessing-hibernate-ann                 |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| ![image](https://user-images.githubusercontent.com/76269316/138814778-f58eff55-187b-4139-876e-c68c69a9346e.png)<br /><span style="color:red">persistence.xml은 META-INF 디렉토리에 저장해야함</span> | ![image](https://user-images.githubusercontent.com/76269316/138814823-6900ad60-db1c-49ca-b164-5b35886af96c.png) |

<br>

**03-3-harnessing-jpa**

![image](https://user-images.githubusercontent.com/76269316/138814778-f58eff55-187b-4139-876e-c68c69a9346e.png)

**persistence.xml**

```xml
<?xml version="1.0" encoding="UTF-8"?>

<persistence
  xmlns="http://xmlns.jcp.org/xml/ns/persistence"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence
  http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd" version="2.1">

  <persistence-unit name="default" transaction-type="RESOURCE_LOCAL">
    <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>  <!-- hibernate jpa를 사용하기 위해 driver(provider) 사용 -->
    <class>com.oreilly.hh.data.Track</class>

    <properties>
      <!--
      <property name="javax.persistence.jdbc.driver" value="org.h2.Driver" />
      <property name="javax.persistence.jdbc.url" value="jdbc:h2:file:./build/music" />
      <property name="javax.persistence.jdbc.user" value="sa" />
      <property name="javax.persistence.jdbc.password" value="" />
      -->

      <property name="hibernate.hbm2ddl.auto" value="update" />
      <property name="hibernate.show_sql" value="false" />
      <property name="hibernate.format_sql" value="false" />

      <property name="hibernate.hikari.dataSourceClassName" value="org.h2.jdbcx.JdbcDataSource" />
      <property name="hibernate.hikari.dataSource.url" value="jdbc:h2:file:./build/music" />
      <property name="hibernate.hikari.dataSource.user" value="sa" />
      <property name="hibernate.hikari.dataSource.password" value="" />

      <property name="hibernate.hikari.minimumIdle" value="4" />
      <property name="hibernate.hikari.maximumPoolSize" value="4" />
      <!-- <property name="hibernate.hikari.idleTimeout" value="30000" /> -->
    </properties>
  </persistence-unit>

  <persistence-unit name="genSchema" transaction-type="RESOURCE_LOCAL">
    <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>
    <class>com.oreilly.hh.data.Track</class>

    <properties>
      <property name="javax.persistence.jdbc.driver" value="org.h2.Driver" />
      <property name="javax.persistence.jdbc.url" value="jdbc:h2:mem:testdb" />
      <property name="javax.persistence.jdbc.user" value="sa" />
      <property name="javax.persistence.jdbc.password" value="" />

      <!-- "none", "create", "drop-and-create", "drop" -->
      <property name="javax.persistence.schema-generation.scripts.action" value="drop-and-create" />
      <property name="javax.persistence.schema-generation.scripts.create-target" value="schema.sql" />
      <property name="javax.persistence.schema-generation.scripts.drop-target" value="schema.sql" />  <!-- 기존에 있는 건 drop하고 새로 create, drop한거랑 create한거를 모두 schema.sql에 저장 -->
    </properties>
  </persistence-unit>

</persistence>
```

persistence unit을 여러개 지정 가능, 위 코드에서는 default와 genSchema 지정

<br>

4. build.gradle

schema generation 하는 부분이 변경됨

<br>

**03-3-harnessing-jpa**

![image](https://user-images.githubusercontent.com/76269316/138815123-73888c20-7f8f-467b-b0a2-234936497d0e.png)

**build.gradle**

```groovy
  task schemajpa(dependsOn: classes, type: JavaExec) {
    group = 'Application'
    description = 'Generates the database schema from JPA entities'

    mainClass = 'com.oreilly.hh.GenerateSchema'
    classpath = sourceSets.main.runtimeClasspath
  }
```

<br>

**03-2-harnessing-hibernate-ann**

![image](https://user-images.githubusercontent.com/76269316/138815259-3e97437f-3ed8-473b-b5b0-5c824ad03c50.png)

**build.gradle**

```groovy
  task schema(dependsOn: classes, type: JavaExec) {
    group = 'Application'
    description = 'Generates the database schema from entities'

    mainClass = 'org.hibernate.tool.hbm2ddl.SchemaExport'
    args '--config=hibernate.cfg.xml', '--text', '--format', '--delimiter=;'
    //args '--create'
    classpath = sourceSets.main.runtimeClasspath
  }
```

hibernate의 경우 schema generation하기 위한 utility class를 호출 (필요한 파라미터를 같이 넘겨줌)

jpa의 경우 이런 툴이 없어서 위에서 만든 프로그램(GenerateSchema.java) 지정

<br><br>

### Kotiln

**03-4-harnessing-jpa-kotlin**

![image](https://user-images.githubusercontent.com/76269316/138815408-701ec3a9-693f-4fb7-9676-fbb571c2e4ae.png)

**Track.kt**

```kotlin
package com.oreilly.hh.data

import java.time.LocalDate
import java.time.LocalTime

import javax.persistence.Column
import javax.persistence.Entity
import javax.persistence.GeneratedValue
import javax.persistence.Id
import javax.persistence.NamedQuery

@NamedQuery(
        name = "com.oreilly.hh.tracksNoLongerThan",
        query = "SELECT track FROM Track as track WHERE track.playTime <= :length")

@Entity
class Track(
    var title: String = "",

    var filePath: String = "",

    var playTime: LocalTime = LocalTime.of(0, 0, 0),

    var added: LocalDate = LocalDate.now(),

    var volume: Short = 0,

    @Id
    @Column(name = "TRACK_ID")
    @GeneratedValue
    var id: Int = 0
) {
    override fun toString(): String = "Track(id=$id, title='$title')"
    override fun equals(other: Any?): Boolean = other is Track && other.id == this.id
    override fun hashCode(): Int = id
}
```

- ;이 없음 (한 줄에 여러 코드가 들어간 경우 구분하기 위해 사용)

- class 이름 (


  ) → default 생성자 역할을 함

- var 키워드를 붙이면 property(private, get(), set())를 만듦 

- 변수명: type

- ```kotlin
  override fun toString(): String = "Track(id=$id, title='$title')“
  ```

  object 출력 시 id, title 값이 채워져서 출력됨

- ```kotlin
  override fun equals(other: Any?): Boolean = other is Track && other.id == this.id
  ```

  argument(other)가 Track 타입이고, id 값이 같으면 true, Track 타입이 아니거나 id 값이 다르면 false 리턴

- ```kotlin
  override fun hashCode(): Int = id
  ```

  데이터베이스에서 생성된 id를 이용할 거기 때문에 어떤 object든 id 값이 같지 않음로 hash는 id값 그냥 이용

<br>

![image](https://user-images.githubusercontent.com/76269316/138815856-8446b929-fe6f-467d-892f-a7bd1d5b3bc0.png)

**CreateTest.kt**

```kotlin
package com.oreilly.hh

import java.time.LocalTime

import javax.persistence.Persistence

import com.oreilly.hh.data.Track

fun main() {
    Persistence.createEntityManagerFactory("default").use { emf ->

        emf.createEntityManager().use { em ->
            em.transaction.use {
                var track = Track("Russian Trance",
                                  "vol2/album610/track02.mp3",
                                  LocalTime.of(0, 3, 30))
                em.persist(track)

                track = Track("Video Killed the Radio Star",
                              "vol2/album611/track12.mp3",
                              LocalTime.of(0, 3, 49))
                em.persist(track)

                track = Track("Gravity's Angel",
                              "vol2/album175/track03.mp3",
                              LocalTime.of(0, 6, 6))
                em.persist(track)
            }
        }
    }
}
```

<br>

```kotlin
    Persistence.createEntityManagerFactory("default").use { emf ->
```

실행시 EntityManagerFactory가 리턴되는데 default entity manager factory object를 argument로(emf) 다음 use 메소드에 전달함

use 메소드 종료시 자동적으로 전달받은 object의 close를 진행

<br>

```kotlin
        emf.createEntityManager().use { em ->
```

넘겨받은 emf로부터 entity manager를 리턴받고 em으로 다음 use 메소드로 전달

<br>

![image](https://user-images.githubusercontent.com/76269316/138816138-21755a5e-c226-4be2-b91a-7ef0b6acc114.png)

**QueryTest.kt**

```kotlin
package com.oreilly.hh

import java.time.LocalTime

import javax.persistence.EntityManager
import javax.persistence.Persistence

import com.oreilly.hh.data.Track

fun tracksNoLongerThan(length: LocalTime, em: EntityManager): List<Track> {
    val query = em.createNamedQuery("com.oreilly.hh.tracksNoLongerThan", Track::class.java)  //Track class를 java language로 리턴
    query.setParameter("length", length)
    return query.resultList
}

fun main() {
    Persistence.createEntityManagerFactory("default").use { emf ->

        emf.createEntityManager().use { em ->
            em.transaction.use {
                val tracks = tracksNoLongerThan(LocalTime.of(0, 7, 0), em)
                for (track in tracks) {
                    println("Track: '${track.title}' ${track.playTime}")
                }
            }
        }
    }
}
```

<br><br>

### **Hibernate jpa and Spring**

**03-5-harnessing-hibernate-spring vs 03-2-harnessing-hibernate-ann**

![image](https://user-images.githubusercontent.com/76269316/138816334-8d021ee9-7130-4f03-a6d5-c1d450e6e081.png)

Spring을 사용한 프로젝트에서는 session factory, session object를 만드는 과정을 PersistenceConfig.java에서 구현

<br>

![image](https://user-images.githubusercontent.com/76269316/138819657-b41a6a65-9a73-4038-9b76-2532da386ac0.png)

**PersistenceConfig.java**

```java
package com.oreilly.hh;

import java.util.Properties;

import javax.sql.DataSource;

import org.hibernate.SessionFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.core.env.Environment;
import org.springframework.orm.hibernate5.HibernateTransactionManager;
import org.springframework.orm.hibernate5.LocalSessionFactoryBean;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

@Configuration  //클래스에 configuration이 붙으면 클래스 메소드에 @Bean을 사용할 수 있음
@PropertySource({ "classpath:jdbc.properties" })
@ComponentScan({ "com.oreilly.hh" })
@EnableTransactionManagement  //transaction try, catch block 생략 가능
public class PersistenceConfig {

    @Autowired
    private Environment env;

    @Bean(destroyMethod = "close")
    public HikariDataSource dataSource() { 
    /*
    dataSource라는 이름의 HikariDataSource object 생성 (configuration에서 object를 어떻게 만들라고 spring한테 주는 지침서)
    이 때 생성한 object를 bean이라고 함 (이 object를 보관하는 걸 container라고 함)
    singleton pattern이 자동 적용 (datasource라는 object 하나 만들고 사용시 재사용)
    spring 사용하지 않으면 직접 object를 만든 다음, 레퍼런스 변수를 할당해서 사용해야함
    */
        var hikariConfig = new HikariConfig("/hikari.properties");
        return new HikariDataSource(hikariConfig);
    }

    // ----------------------------------------------
    // Hibernate
    // ----------------------------------------------

    //hiberbate에서 제공하는 session factory가 아닌 spring에서 제공하는 local session factory 사용
    @Bean
    public LocalSessionFactoryBean sessionFactory() {
        var sessionFactory = new LocalSessionFactoryBean();
        sessionFactory.setDataSource(dataSource());
        sessionFactory.setPackagesToScan(new String[] { "com.oreilly.hh.data" });  //array로 선언했기 때문에 여러 패키지를 받을 수 있음
    /*
    hibernate에서는 hibernate.cfg.xml 파일에서 entity class(@Entity가 있는 클래스 – ex: Track.java)나 mapping 파일을 일일이 나열
    spring에서는 찾아봐야할 패키지랑 path를 알려주면 알아서 해당 경로를 탐색함
    */
        sessionFactory.setHibernateProperties(hibernateProperties());

        return sessionFactory;
    }

    //@bean이 안 붙어있으니까 순수한 java 메소드
    Properties hibernateProperties() {
        return new Properties() {
            {
                setProperty("hibernate.dialect", env.getRequiredProperty("hibernate.dialect"));
                setProperty("hibernate.hbm2ddl.auto", "update");
                // setProperty("hibernate.show_sql", "true");
                // setProperty("hibernate.format_sql", "true");
            }
        };
    }

    @Bean
    public HibernateTransactionManager transactionManager(SessionFactory sessionFactory) {
        var transactionManager = new HibernateTransactionManager();
        transactionManager.setSessionFactory(sessionFactory);
        return transactionManager;
    }

}
```

hibernate에서는 데이터베이스의 테이블에 대응하는 클래스를 entity라고 함

spring에서는 bean이라고 함

 <br>

**PersistenceConfig.java**

```java
@PropertySource({ "classpath:jdbc.properties" })
                    ···
public class PersistenceConfig {

    @Autowired
    private Environment env;                    
```

configuration 파일에서 jdbc.properties 파일을 읽어서 env 변수에 binding

![image](https://user-images.githubusercontent.com/76269316/138820446-e4e8cdaf-ba10-4561-b191-cbbcfcf74b30.png)

**jdbc.properties**

```properties
# Hibernate Property
hibernate.dialect=org.hibernate.dialect.H2Dialect
hibernate.hbm2ddl.auto=update

# H2
jdbc.driverClassName=org.h2.Driver
jdbc.url=jdbc:h2:file:./build/music
jdbc.username=sa
jdbc.password=
```

<br>

**PersistenceConfig.java**

```java
    Properties hibernateProperties() {
        return new Properties() {
            {
                setProperty("hibernate.dialect", env.getRequiredProperty("hibernate.dialect"));  //getRequiredProperty: 없거나 잘못쓰면 에러 발생
                              ···
            }
        };
    }
```

env에서 hibernate.dialect라는 속성을 읽어오는 코드 (데이터베이스 서버가 변경되면 property를 자동으로 변경시키기 위해)

<br>

![image](https://user-images.githubusercontent.com/76269316/138820964-ccfd2131-ce6d-42b2-aec5-40eeee0e09b2.png)

**CreateTest.java**

```java
package com.oreilly.hh;

import java.time.LocalTime;

import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.oreilly.hh.data.Track;

public class CreateTest {

    public static void main(String args[]) {

        var context = new AnnotationConfsigApplicationContext(PersistenceConfig.class);  
        //spring에서는 PersistenceConfig.java 파일로 설계도를 주고 그걸 토대로 container를 초기화 (application context라고 함)
        
        //var context = new ClassPathXmlApplicationContext("applicationContext.xml");
		//처음에는 xml로 application context를 줬음

        /*
        context 안에 session factory가 만들어져있음
        이름으로 호출할 수도 있는데 type별로 하나만 만들어져 있으니까 클래스이름으로 호출 (SessionFactory 클래스 타입이거나 상속받은 하위 클래스를 찾아서 리턴)
        */
        var sessionFactory = context.getBean(SessionFactory.class);
        var session = sessionFactory.openSession();
        Transaction tx = null;

        try {
            tx = session.beginTransaction();  //여기서는 transaction을 직접 처리하고 있어서 spring을 사용하지 않을 때처럼 직접 catch문 작성

            var track = new Track("Russian Trance",
                                  "vol2/album610/track02.mp3",
                                  LocalTime.of(00,03,30));
            session.save(track);

            track = new Track("Video Killed the Radio Star",
                              "vol2/album611/track12.mp3",
                              LocalTime.of(00,03,49));
            session.save(track);

            track = new Track("Gravity's Angel",
                              "vol2/album175/track03.mp3",
                              LocalTime.of(00,06,06));
            session.save(track);

            tx.commit();
        } catch (RuntimeException e) {
            if (tx != null) tx.rollback();
            throw e;
        } finally {
            session.close();
        }

        sessionFactory.close();
        context.close();
    }
}
```

<br>

![image](https://user-images.githubusercontent.com/76269316/138821143-5f72eabe-cd0f-432b-a009-6035c7ce0f93.png)

**build.gradle**

```groovy
  dependencies {
    // Slf4j
    implementation     'org.slf4j:slf4j-api'
    runtimeOnly        'ch.qos.logback:logback-classic'

    // JUnit 5
    testImplementation 'org.junit.jupiter:junit-jupiter'
    testImplementation 'org.assertj:assertj-core'

    // Spring
    implementation     'org.springframework:spring-context'
    implementation     'org.springframework:spring-orm'  //hibernate나 jpa를 사용하는 경우 추가
    testImplementation 'org.springframework:spring-test'

    // Hibernate
    implementation     'org.hibernate:hibernate-core'
    implementation     'org.hibernate:hibernate-hikaricp'  //context를 xml(hibernate.cfg.xml)로 초기화하는 경우 ruintimeOnly 사용, java(PersistenceConfig.java)로 하는 경우 implementation 

    // JDBC Driver
    runtimeOnly        'com.h2database:h2'
    runtimeOnly        'org.postgresql:postgresql'
  }
}
```

hibernate를 사용하면 schema 생성시 라이브러리를 직접 호출하면 되는데(hibernate.cfg.xml이 없기 때문) spring에서는 없음

+hibernate schema generation

![image](https://user-images.githubusercontent.com/76269316/138821994-0afbbc73-4be0-4db3-a8b9-0c4352d73d03.png)

**build.gradle**

```groovy
  task schema(dependsOn: classes, type: JavaExec) {
    group = 'Application'
    description = 'Generates the database schema from entities'

    mainClass = 'org.hibernate.tool.hbm2ddl.SchemaExport'
    args '--config=hibernate.cfg.xml', '--text', '--format', '--delimiter=;'
    //args '--create'
    classpath = sourceSets.main.runtimeClasspath
  }
```

--config: hibernate configure파일 위치 

--text: 화면에 text로 출력

--format: format을 xml로

--delimiter: delimeter를 ;로 설정

--create: 실제 데이터베이스에도 생성

classpath: dependency에 기술된 runtimeClasspath를 가져옴

![image](https://user-images.githubusercontent.com/76269316/138822100-982aa7ef-90e3-4cbd-a636-438f92eeb7ab.png)

<br>spring 사용시 dependency 버전을 명시하지 않아도 됨

![image](https://user-images.githubusercontent.com/76269316/138821143-5f72eabe-cd0f-432b-a009-6035c7ce0f93.png)

**build.gradle**

```groovy
plugins {
  id 'java'
  id 'application'
  id 'io.freefair.lombok'

  id 'org.springframework.boot'        apply false
  id 'io.spring.dependency-management' apply false  //plugin을 불러오기만하고 적용 x
}

allprojects {  
  apply plugin: 'io.spring.dependency-management'  
  /*
  이렇게 초기화를 해놓으면 밑에 dependency 설정시 버전을 명시하지 않아도됨
  spring이 라이브러리끼지 호환성 테스트를 거쳐 버전을 자동으로 명시함
  */
					···
  dependencies {
    // Slf4j
    implementation     'org.slf4j:slf4j-api'
    runtimeOnly        'ch.qos.logback:logback-classic'

    // JUnit 5
    testImplementation 'org.junit.jupiter:junit-jupiter'
    testImplementation 'org.assertj:assertj-core'

    // Spring
    implementation     'org.springframework:spring-context'
    implementation     'org.springframework:spring-orm'
    testImplementation 'org.springframework:spring-test'

    // Hibernate
    implementation     'org.hibernate:hibernate-core'
    implementation     'org.hibernate:hibernate-hikaricp'

    // JDBC Driver
    runtimeOnly        'com.h2database:h2'
    runtimeOnly        'org.postgresql:postgresql'
  }
}
```

<br><br>

**03-6-harnessing-jpa-spring vs 03-3-harnessing-jpa**

![image](https://user-images.githubusercontent.com/76269316/138823113-a90c618e-9478-4410-95dd-c25937a47f83.png)

<br>

**03-6-harnessing-jpa-spring**

![image](https://user-images.githubusercontent.com/76269316/138823247-68389a39-df7f-4caf-9ed3-514f7e2a2de8.png)

**PersistenceConfig.java**

```java
package com.oreilly.hh;

import java.util.Properties;

import javax.persistence.EntityManagerFactory;
import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.core.env.Environment;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

@Configuration
@PropertySource({ "classpath:jdbc.properties" })
@ComponentScan({ "com.oreilly.hh" })
@EnableTransactionManagement
public class PersistenceConfig {

    @Autowired
    private Environment env;

    @Bean(destroyMethod = "close")
    public HikariDataSource dataSource() {
        var hikariConfig = new HikariConfig("/hikari.properties");
        return new HikariDataSource(hikariConfig);
    }

    // ----------------------------------------------
    // JPA
    // ----------------------------------------------

    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {  //SessionFactory가 EntityManagerFactory로 변경됨
        var emf = new LocalContainerEntityManagerFactoryBean();
        emf.setDataSource(dataSource());
        emf.setPackagesToScan(new String[] { "com.oreilly.hh" });
        emf.setJpaVendorAdapter(new HibernateJpaVendorAdapter());  //설정할게 없음 (default 생성자 사용)
        emf.setJpaProperties(hibernateProperties());

        return emf;
    }

    Properties hibernateProperties() {
        return new Properties() {
            {
                setProperty("hibernate.dialect", env.getRequiredProperty("hibernate.dialect"));
                setProperty("hibernate.hbm2ddl.auto", "update");
                // setProperty("hibernate.show_sql", "true");
                // setProperty("hibernate.format_sql", "true");
            }
        };
    }

    @Bean
    public JpaTransactionManager transactionManager(EntityManagerFactory emf) {  //HibernateTransactionManager가 JpaTransactionManager로 변경됨
        var transactionManager = new JpaTransactionManager();
        transactionManager.setEntityManagerFactory(emf);
        return transactionManager;
    }
}
```

![image](https://user-images.githubusercontent.com/76269316/138823606-4ee098cf-326b-4999-9149-a06306c004d3.png)

CreateTest.java의 경우 위에서 본 hibernate에서 spring을 사용했을 때와 동일

<br>

![image](https://user-images.githubusercontent.com/76269316/138823657-5381b821-fe10-4100-ba9e-efc7fd75d71e.png)

**hikari.properties**

```properties
# H2
dataSourceClassName=org.h2.jdbcx.JdbcDataSource
username=sa
password=
autoCommit=false
minimumIdle=1  #connection을 최소 1개, 최대 4개 유지
maximumPoolSize=4
dataSource.url=jdbc:h2:file:./build/music
```

<br><br>

### spring config vs spring boot and dao vs springDataJpa

**03-7-harnessing-jpa-dao-spring vs 03-6-harnessing-jpa-spring**

![image](https://user-images.githubusercontent.com/76269316/138823905-4e7f36ce-6417-467c-9b92-047c7ab830c7.png)

DAO(Data Access Object): 데이터베이스에 접근하는 기술에 관련된 layer를 인터페이스로 따로 생성해서 숨김

<br>

![image](https://user-images.githubusercontent.com/76269316/138824112-7b38748c-a867-4866-908b-eed25b565d25.png)

**TrackDAO.java**

```java
package com.oreilly.hh.dao;

import java.time.LocalTime;
import java.util.List;

import com.oreilly.hh.data.Track;

public interface TrackDAO {
    Track save(Track track);
    void delete(Track track);
    Track findById(int id);
    List<Track> findAll();
    List<Track> findByNameLike(String namePattern);
    List<Track> tracksNoLongerThan(LocalTime length);
}
```

<br>

![image](https://user-images.githubusercontent.com/76269316/138824276-55d3898e-0e1b-430c-b8a8-46b58c265963.png)

**TrackHibernateDAO.java**

TrackDAO 인터페이스를 구현한 클래스

```java
package com.oreilly.hh.dao.hibernate;

import java.time.LocalTime;
import java.util.List;

import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import com.oreilly.hh.dao.TrackDAO;
import com.oreilly.hh.data.Track;

@Repository  //spring container가 이 클래스를 찾아서 bean으로 등록하는데 repository type으로 등록 → 이걸 찾는 애가 ComponentScan
@Transactional  //여기에 선언된 메소드들을 유저가 사용할 때 호출하기 전에 transaction을 시작하고, 정상적으로 끝나면 commit을 해주고 exception이 발생하면 rollback을 자동으로 시켜줌
public class TrackHibernateDAO implements TrackDAO {

    //PersistenceConfig.java에서 EntityManagerFactory를 생성 
    @PersistenceContext  
    /*
    이 annotation을 붙여주면 현재 TrackHibernateDAO object를 만드는 순간 context내의 EntityManagerFactory로부터 EntityManager를 만들어서 연결시켜줌
    EntityManager는 context에 하나만 만들어놓고 재사용할 수 없음 → 쓰레드별로 하나씩만 유지
    */
    private EntityManager em;

    public Track save(Track track) {
        em.persist(track);
        return track;
    }

    public void delete(Track track) {
        em.remove(track);
    }

    public Track findById(int id) {
        return em.find(Track.class, id);
    }

    public List<Track> findAll() {
        var hql = "SELECT t FROM Track t";
        return em.createQuery(hql, Track.class)
                 .getResultList();
    }

    public List<Track> findByNameLike(final String namePattern) {
        var hql = "SELECT t FROM Track t WHERE name LIKE :name";
        return em.createQuery(hql, Track.class)
                 .setParameter("name", namePattern)
                 .getResultList();
    }

    public List<Track> tracksNoLongerThan(LocalTime length) {
        return em.createNamedQuery("com.oreilly.hh.tracksNoLongerThan", Track.class)
                 .setParameter("length", length)
                 .getResultList();
    }
}
```

이렇게 인터페이스를 구현한걸 다른 layer에서는 그냥 받아서 사용하면 됨 → 소스코드 안정성 ↑ (만약 hibernate말고 jpa로 변경시 TrackDao.java, TrackHibernateDAO.java 이 부분만 변경하면 됨)

<br>

![image](https://user-images.githubusercontent.com/76269316/138824949-6ed7a2c7-22df-4b80-99ae-624314c84e3d.png)

**PersistenceConfig.java**

```java
package com.oreilly.hh;

import java.util.Properties;

import javax.persistence.EntityManagerFactory;
import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;
import org.springframework.core.env.Environment;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;
import org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter;
import org.springframework.transaction.annotation.EnableTransactionManagement;

import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

@Configuration
@PropertySource({ "classpath:jdbc.properties" })
@ComponentScan({ "com.oreilly.hh" })  //spring bean을 스캔(PersistenceConfig.java 내에 있는건 읽으면서 bean을 만들고 componentScan 파라미터로 주어진 디렉토리를 찾아가서 @Component, @Repository, @Service가 붙어있는 클래스를 bean으로 등록)
@EnableTransactionManagement
public class PersistenceConfig {

    @Autowired  //현재 context에 Environment type으로 bean화 돼 있는 object를 env에 binding
    private Environment env;

    @Bean(destroyMethod = "close")
    public HikariDataSource dataSource() {
        var hikariConfig = new HikariConfig("/hikari.properties");
        return new HikariDataSource(hikariConfig);
    }

    // ----------------------------------------------
    // JPA
    // ----------------------------------------------

    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
        var emf = new LocalContainerEntityManagerFactoryBean();
        emf.setDataSource(dataSource());
        emf.setPackagesToScan(new String[] { "com.oreilly.hh" });
        emf.setJpaVendorAdapter(new HibernateJpaVendorAdapter());
        emf.setJpaProperties(hibernateProperties());

        return emf;
    }

    Properties hibernateProperties() {
        return new Properties() {
            {
                setProperty("hibernate.dialect", env.getRequiredProperty("hibernate.dialect"));
                setProperty("hibernate.hbm2ddl.auto", "update");
                // setProperty("hibernate.show_sql", "true");
                // setProperty("hibernate.format_sql", "true");
            }
        };
    }

    @Bean
    public JpaTransactionManager transactionManager(EntityManagerFactory emf) {
        var transactionManager = new JpaTransactionManager();
        transactionManager.setEntityManagerFactory(emf);
        return transactionManager;
    }
}
```

<br>

**PersistenceConfig.java**

```java
    @Bean
    public JpaTransactionManager transactionManager(EntityManagerFactory emf) {
        var transactionManager = new JpaTransactionManager();
        transactionManager.setEntityManagerFactory(emf);
        return transactionManager;
    }
```

Transaction Manager를 선언하고,

```java
@EnableTransactionManagement
```

annotation을 선언하면

**TrackHibernateDAO.java**

![image](https://user-images.githubusercontent.com/76269316/138825195-2bb2a8ea-ac58-4d98-8551-0155c7fcbc12.png)

```java
@Repository
@Transactional
public class TrackHibernateDAO implements TrackDAO {
					···
```

@Repository, @Transactional annotation이 붙은 클래스 내의 메소드는 transaction을 자동으로 관리해줌

+@Transactional을 메소드 위에 붙이면 이게 붙은 메소드만 transaction 관리

<br>

![image](https://user-images.githubusercontent.com/76269316/138825399-a4f3ec9d-fc1d-4c33-a594-ee294ae1c4e4.png)

**CreateTest.java**

```java
package com.oreilly.hh;

import java.time.LocalTime;

import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import com.oreilly.hh.dao.TrackDAO;
import com.oreilly.hh.data.Track;

public class CreateTest {

    public static void main(String args[]) {
        //application context 초기화
        var context = new AnnotationConfigApplicationContext(PersistenceConfig.class);
        
        //var context = new ClassPathXmlApplicationContext("applicationContext.xml");

        var trackDAO = context.getBean(TrackDAO.class);  //trackDAO 인터페이스를 구현한 클래스 (trackDAO 클래스 타입이거나 상속받은 하위 클래스를 찾아서 리턴)

        var track = new Track("Russian Trance",
                              "vol2/album610/track02.mp3",
                              LocalTime.of(00,03,30));
        trackDAO.save(track);  //메소드 실행시 transaction 시작 종료

        track = new Track("Video Killed the Radio Star",
                          "vol2/album611/track12.mp3",
                          LocalTime.of(00,03,49));
        trackDAO.save(track);  //메소드 실행시 transaction 시작 종료

        track = new Track("Gravity's Angel",
                          "vol2/album175/track03.mp3",
                          LocalTime.of(00,06,06));
        trackDAO.save(track);  //메소드 실행시 transaction 시작 종료

        context.close();
    }
}
```

transaction이 너무 빈번하게 일어남

현재는 data access layer이고, 어플리케이션에서 필요한 기능을 구현하는게 service layer임 (service layer에서는 좀 더 큰 단위의 transaction 선언 가능)

configuration시 PersistenceConfig.java의 내용은 거의 같은데 조금씩 다름 → 사용하는 라이브러리에 따라서 application context 초기화를 자동화한 것이 spring boot

<br><br>

**03-8-harnessing-jpa-dao-springboot vs 03-7-harnessing-jpa-dao-spring**

![image](https://user-images.githubusercontent.com/76269316/138825707-166656ac-0029-4744-a65f-b6a8cc4372ef.png)

- persistanceConfig.java 파일이 사라짐 (springboot가 자동으로 best practice를 추가함)

- springboot 방식은 어플리케이션이 여러개인게 불편해서 App.java로 합침 (CreateTest, QueryTest)

- 데이터베이스를 관리하는 파일(hikari.properties, jdbc.properties)도 사라짐

<br>

![image](https://user-images.githubusercontent.com/76269316/138826061-c9d76879-6b97-48e0-97c2-9a81393a213d.png)

**application.properties**

```properties
spring.output.ansi.enabled=ALWAYS  #로그 메시지 출력시 터미널인 경우 color로 출력 (auto detection이 안 좋아서 터미널임에도 coloring이 안되는 경우도 있음)

#아래 네 줄은 생략돼도 되는데 데이터베이스 서버 정보를 정확하게 지정하고 싶어 명시
#생략시 h2 데이터베이스에 메모리 DB 파일 방식으로 움직여서 프로그램 시작시 만들고 종료시 삭제함
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.url=jdbc:h2:file:./build/music
spring.datasource.username=sa 
spring.datasource.password=

spring.jpa.hibernate.ddl-auto=update

logging.level.com.oreilly.hh=DEBUG
#logging.level.org.springframework.orm.jpa=DEBUG
#logging.level.com.zaxxer.hikari.pool.ProxyConnection=DEBUG
```

<br>

spring boot는 dependency를 바탕으로 유추해서 PersistenceConfig.java를 auto generation함

![image](https://user-images.githubusercontent.com/76269316/138827552-b14dbdf4-6129-433a-aa0b-f719508d8506.png)

**build.gradle**

```groovy
plugins {
  id 'java'
  id 'io.freefair.lombok'

  id 'org.springframework.boot'
  id 'io.spring.dependency-management'
}

repositories {
  mavenCentral()
}

dependencies {
  implementation     'org.springframework.boot:spring-boot-starter-data-jpa’  //현재 이 프로젝트는 jpa를 사용하고 있고, spring data jpa 기능을 사용
  testImplementation 'org.springframework.boot:spring-boot-starter-test'

  runtimeOnly        'com.h2database:h2'  //데이터베이스 드라이버 로딩
}

test {
  useJUnitPlatform()

  outputs.upToDateWhen {false}
  testLogging {
    events = ['passed', 'skipped', 'failed']
    showStandardStreams = true
    exceptionFormat = 'full'
  }
}
```

<br>

![image](https://user-images.githubusercontent.com/76269316/138827706-8652fe2f-b872-40d7-b060-d70749440dc5.png)

**App.java**

```java
package com.oreilly.hh;

import java.time.LocalTime;
import java.util.*;

import javax.persistence.*;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;

import com.oreilly.hh.dao.TrackDAO;
import com.oreilly.hh.data.*;

@SpringBootApplication  //이게 @Configuration, @PropertySource, @ComponentScan, @EnableTransactionManagement를 다 포함하고 있음
public class App {

    private static final Logger log = LoggerFactory.getLogger(App.class);

    public static void main(String[] args) {
        SpringApplication.run(App.class, args).close();  //context manager에서 bean을 만들고 application context를 초기화
    }

/*
실제로 돌려보고 싶은 기능이 있는 경우 App 자체가 bean이기 때문에 @bean annotation을 붙여서 configuration 할 수 있는 object를 bean으로 등록할 수 있음

SpringApplication.run이 실행되면 application context가 초기화되고, CommandLineRunner를 다 찾아서(여러개 있을 수 있음) 실행하고 다 끝나고 나면 close하고 빠져나옴
*/

    @Bean
    public CommandLineRunner demo(TrackDAO trackDAO) {
        return (args) -> {

            //
            // CreateTest
            //

            var track = new Track("Russian Trance",
                                  "vol2/album610/track02.mp3",
                                  LocalTime.of(00,03,30));
            trackDAO.save(track);

            track = new Track("Video Killed the Radio Star",
                              "vol2/album611/track12.mp3",
                              LocalTime.of(00,03,49));
            trackDAO.save(track);

            track = new Track("Gravity's Angel",
                              "vol2/album175/track03.mp3",
                              LocalTime.of(00,06,06));
            trackDAO.save(track);

            //
            // QueryTest
            //

            List<Track> tracks = trackDAO.tracksNoLongerThan(LocalTime.of(00,07,00));

            for (Track t : tracks) {
                System.out.printf("Track: \"%s\" %s\n", t.getTitle(), t.getPlayTime());
            }
        };
    }
}
```

springboot는 gradle bootRun으로 실행 (springboot의 경우 build.gradle에 자동생성해서 build.gradle에 관련 코드가 없음)

<br>

**03-9-harnessing-springDataJpa-springboot vs 03-8-harnessing-jpa-dao-springboot**

![image](https://user-images.githubusercontent.com/76269316/138827985-14711e3f-d315-49fc-bb6c-a6f12c35c23e.png)

DAO를 springDataJpa로 대체, 인터페이스(TrackDAO.java) 부분만 남고 구현한 파일(TrackHibernateDAO.java)이 사라짐

<br>

![image](https://user-images.githubusercontent.com/76269316/138828302-782504d8-0dd2-4ad0-8ba6-6ef7dc24ddc5.png)

```groovy
plugins {
  id 'java'
  id 'io.freefair.lombok'

  id 'org.springframework.boot'
  id 'io.spring.dependency-management'
}

repositories {
  mavenCentral()
}

dependencies {
  implementation     'org.springframework.boot:spring-boot-starter-data-jpa'  // data jpa 사용
  testImplementation 'org.springframework.boot:spring-boot-starter-test'

  runtimeOnly        'com.h2database:h2'
}

test {
  useJUnitPlatform()

  outputs.upToDateWhen {false}
  testLogging {
    events = ['passed', 'skipped', 'failed']
    showStandardStreams = true
    exceptionFormat = 'full'
  }
}
```

<br>

![image](https://user-images.githubusercontent.com/76269316/138828519-3b27c16a-62e8-40e7-8300-378261a3972d.png)

**TrackDAO.java**

```java
package com.oreilly.hh.dao;

import java.time.LocalTime;
import java.util.List;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import com.oreilly.hh.data.Track;

@Repository
@Transactional
/*
TrackDAO가 인터페이스인데 spring jpa가 지원하는 클래스(JpaRepository)를 상속 받음
Track 클래스에 대한 repository를 만듦 (id column type은 integer)
save, saveAll, delete, deleteById ···을 auto generation
*/
public interface TrackDAO extends JpaRepository<Track, Integer> {
    /* Methods autogenerated by Spring Data Jpa:
    Track       save(S entity);
    List<Track> saveAll(Iterable<S> entities);

    void        delete(T entity);
    void        deleteById(ID id)
    void        deleteAll()

    Optional<T> findById(ID primaryKey);
    Iterable<T> findAll();
    Iterable<T> findAllById(Iterable<ID> ids);
    */

    /* Autogenerated by User request */
    List<Track> findByPlayTimeLessThanEqual(LocalTime length);  
    /*
    PlayTime field보다 작거나 같은 경우 (규약이 있음) → 이것도 auto generation
    이걸로도 안되는 경우 우리가 직접 메소드를 만들어서 넣을 수도 있음
    */
}
```
